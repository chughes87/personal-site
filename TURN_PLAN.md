# TURN Server Plan

## Overview

Add a self-hosted coturn TURN server on EC2 so WebRTC voice connections succeed in
symmetric NAT / corporate firewall environments. The server starts automatically when
the first person joins the voice room and stops when the room has been empty for a few
minutes. No third party sees connection metadata.

**AWS cost target: ~$1–2/month** at light use (EC2 stopped when idle).

---

## Architecture

```
Frontend (voice.js)
  │
  ├─ POST /voice/join  ──►  Lambda voiceJoin
  │                            ├─ write participant to DynamoDB
  │                            ├─ if room was empty: StartInstances (fire-and-forget)
  │                            └─ return { clientId, participants,
  │                                        turn: { username, credential },
  │                                        turnReady: bool }
  │
  ├─ GET /voice/turn/status  ──►  Lambda turnStatus
  │                                 ├─ DescribeInstances
  │                                 └─ { ready: bool, host: string|null }
  │
  ├─ POST /voice/leave  ──►  Lambda voiceLeave
  │                            ├─ delete participant from DynamoDB
  │                            ├─ query remaining participants
  │                            └─ if room now empty: StopInstances
  │
  └─ (scheduled every 5 min)  ──►  Lambda turnIdleStop
                                     ├─ query participants
                                     └─ if empty and EC2 running: StopInstances

coturn EC2 (t3.nano, us-west-1, Ubuntu 22.04 LTS)
  ├─ UDP/TCP 3478  (TURN)
  ├─ UDP 49152-65535  (relay range)
  └─ short-term HMAC credentials (shared secret with Lambda)
```

**TURN credentials** are short-lived HMAC tokens generated by Lambda at join time.
The shared secret (`TURN_SECRET`) lives only in Lambda env vars and the coturn config —
never in client code.

---

## Cost Breakdown

| Item | Est. monthly |
|---|---|
| t3.nano EC2 (2 hrs/day running) | ~$0.31 |
| t3.nano EC2 (8 hrs/day running) | ~$1.25 |
| Elastic IP | **$0** (not used — dynamic IP fetched at start time) |
| EBS root volume (8 GB gp3) | ~$0.64 |
| Lambda (extra EC2 API calls) | ~$0 |
| Bandwidth (only relayed traffic) | $0.09/GB |

**Key:** No Elastic IP is used. Lambda calls `DescribeInstances` after start to get the
current public IP. This means IP changes each start — that's fine because clients fetch
it via the `/voice/turn/status` endpoint.

---

## Checklist

### Phase 1 — EC2 / coturn setup (manual, one-time)

- [ ] Create security group `coturn-sg` in us-west-1:
  - Inbound UDP 3478 from 0.0.0.0/0
  - Inbound TCP 3478 from 0.0.0.0/0
  - Inbound UDP 49152–65535 from 0.0.0.0/0
  - Inbound TCP 22 from your IP only (or omit and use SSM)
  - Outbound: all traffic
- [ ] Launch t3.nano EC2 (Ubuntu 22.04 LTS, us-west-1), attach `coturn-sg`
- [ ] Attach IAM instance profile with `AmazonSSMManagedInstanceCore` policy
  (enables SSM Session Manager — avoid opening port 22)
- [ ] SSH/SSM in and install coturn + configure:
  - `sudo apt-get update && sudo apt-get install -y coturn`
  - Write `/etc/turnserver.conf` (see spec below)
  - Write `/usr/local/bin/coturn-setup.sh` (fetches public IP on boot)
  - Write `/etc/systemd/system/coturn-setup.service` (runs before coturn)
  - `sudo systemctl enable coturn-setup coturn`
- [ ] Generate `TURN_SECRET`: `openssl rand -hex 32`
- [ ] Write secret into `/etc/turnserver.conf` (`static-auth-secret=...`)
- [ ] Note the EC2 Instance ID (e.g. `i-0abc123...`)
- [ ] Stop the instance (it will be started on demand by Lambda)

### Phase 2 — Lambda + SAM

- [ ] `package.json` — add `@aws-sdk/client-ec2` dependency
- [ ] `api/handler.js` — import `EC2Client`, `StartInstancesCommand`,
  `StopInstancesCommand`, `DescribeInstancesCommand`
- [ ] `api/handler.js` — add `TURN_EC2_INSTANCE_ID` and `TURN_SECRET` env var reads
- [ ] `api/handler.js` — add `turnCredentials(clientId)` helper
- [ ] `api/handler.js` — add `getEc2State()` helper (returns `{ state, publicIp }`)
- [ ] `api/handler.js` — add `startTurnServer()` and `stopTurnServer()` helpers
- [ ] `api/handler.js` — modify `voiceJoin`: start EC2 if room was empty before this
  join; return `turn: { username, credential }` and `turnReady: bool` in response
- [ ] `api/handler.js` — modify `voiceLeave`: after deleting participant, check room
  count; if empty call `stopTurnServer()`
- [ ] `api/handler.js` — add `turnStatus()` handler for `GET /voice/turn/status`
- [ ] `api/handler.js` — add `turnIdleStop()` handler for scheduled cleanup
- [ ] `api/handler.js` — extend voice router with `turn/status` and the schedule path
- [ ] `api/template.yaml` — add `TURN_EC2_INSTANCE_ID` and `TURN_SECRET` env vars
- [ ] `api/template.yaml` — add EC2 IAM policy to Lambda role:
  `ec2:StartInstances`, `ec2:StopInstances`, `ec2:DescribeInstances`
- [ ] `api/template.yaml` — bump `Timeout` to 15s (EC2 API calls can be slow)
- [ ] `api/template.yaml` — add `TurnIdleStopFunction` (or EventBridge rule on same
  function) scheduled every 5 minutes

### Phase 3 — Frontend

- [ ] `src/voice.js` — remove hardcoded `STUN` const
- [ ] `src/voice.js` — add `let turnConfig = null` state var
- [ ] `src/voice.js` — add `buildIceConfig(host, username, credential)` helper
- [ ] `src/voice.js` — in `joinRoom`: store turn credentials from response; if
  `turnReady: false`, call `waitForTurn()` before creating PeerConnections
- [ ] `src/voice.js` — add `waitForTurn()`: polls `/voice/turn/status` every 3s,
  shows "Starting TURN server (~30s)..." status; resolves when ready
- [ ] `src/voice.js` — replace `STUN` with `turnConfig` (falls back to STUN-only if
  TURN_SECRET not configured, e.g. local dev)
- [ ] `src/voice.js` — pass `turnConfig` to `makePc()` instead of `STUN`

### Phase 4 — Tests

- [ ] `tests/api/handler.test.js` — mock `@aws-sdk/client-ec2`
- [ ] `tests/api/handler.test.js` — `turnCredentials()`: assert username format and
  HMAC password are correct (test against known secret + timestamp)
- [ ] `tests/api/handler.test.js` — `voiceJoin` when room empty: assert
  `StartInstancesCommand` called; response includes `turn` object
- [ ] `tests/api/handler.test.js` — `voiceJoin` when room non-empty: assert
  `StartInstancesCommand` NOT called
- [ ] `tests/api/handler.test.js` — `voiceLeave` last participant: assert
  `StopInstancesCommand` called
- [ ] `tests/api/handler.test.js` — `voiceLeave` not last: assert stop NOT called
- [ ] `tests/api/handler.test.js` — `GET /voice/turn/status` when running: returns
  `{ ready: true, host: "1.2.3.4" }`
- [ ] `tests/api/handler.test.js` — `GET /voice/turn/status` when pending: returns
  `{ ready: false, host: null }`
- [ ] `tests/src/voice.test.js` — `waitForTurn`: polls until ready, sets `turnConfig`
- [ ] `tests/src/voice.test.js` — `makePc` uses `turnConfig` when set

---

## coturn Config (`/etc/turnserver.conf`)

```
listening-port=3478
fingerprint
use-auth-secret
static-auth-secret=REPLACE_WITH_TURN_SECRET
realm=pointfree.space

# Relay port range
min-port=49152
max-port=65535

# Security: block relay to private/internal IPs (prevent SSRF)
no-loopback-peers
no-multicast-peers
denied-peer-ip=0.0.0.0-0.255.255.255
denied-peer-ip=10.0.0.0-10.255.255.255
denied-peer-ip=100.64.0.0-100.127.255.255
denied-peer-ip=127.0.0.0-127.255.255.255
denied-peer-ip=169.254.0.0-169.254.255.255
denied-peer-ip=172.16.0.0-172.31.255.255
denied-peer-ip=192.0.0.0-192.0.0.255
denied-peer-ip=192.168.0.0-192.168.255.255

# Quota
total-quota=50

# External IP — overwritten at boot by coturn-setup.sh
external-ip=0.0.0.0
```

---

## Boot-time IP script (`/usr/local/bin/coturn-setup.sh`)

coturn needs `external-ip` set to the EC2's current public IP. Since we don't use an
Elastic IP, the public IP changes on each start. This script runs as a systemd service
before coturn starts:

```bash
#!/bin/bash
PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)
sed -i "s/^external-ip=.*/external-ip=$PUBLIC_IP/" /etc/turnserver.conf
```

```ini
# /etc/systemd/system/coturn-setup.service
[Unit]
Description=Configure coturn external IP before start
Before=coturn.service
After=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/coturn-setup.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
```

---

## Lambda Code Sketch

### TURN credential generation

```js
const crypto = require('crypto');
const { EC2Client, StartInstancesCommand, StopInstancesCommand, DescribeInstancesCommand } = require('@aws-sdk/client-ec2');

const ec2 = new EC2Client({ region: 'us-west-1' });
const TURN_SECRET           = process.env.TURN_SECRET || '';
const TURN_EC2_INSTANCE_ID  = process.env.TURN_EC2_INSTANCE_ID || '';

function turnCredentials(clientId) {
  const expiry   = Math.floor(Date.now() / 1000) + 3600;  // 1-hour TTL
  const username = `${expiry}:${clientId}`;
  const credential = crypto.createHmac('sha1', TURN_SECRET).update(username).digest('base64');
  return { username, credential };
}
```

### EC2 helpers

```js
async function getEc2State() {
  if (!TURN_EC2_INSTANCE_ID) return { state: 'unavailable', publicIp: null };
  const res  = await ec2.send(new DescribeInstancesCommand({ InstanceIds: [TURN_EC2_INSTANCE_ID] }));
  const inst = res.Reservations?.[0]?.Instances?.[0];
  return { state: inst?.State?.Name ?? 'unknown', publicIp: inst?.PublicIpAddress ?? null };
}

async function startTurnServer() {
  if (!TURN_EC2_INSTANCE_ID) return;
  await ec2.send(new StartInstancesCommand({ InstanceIds: [TURN_EC2_INSTANCE_ID] }));
}

async function stopTurnServer() {
  if (!TURN_EC2_INSTANCE_ID) return;
  await ec2.send(new StopInstancesCommand({ InstanceIds: [TURN_EC2_INSTANCE_ID] }));
}
```

### Modified `voiceJoin` (additions only)

```js
// After writing the new participant record and before returning:
const credentials = TURN_SECRET ? turnCredentials(clientId) : null;

if (credentials) {
  const wasEmpty = existing.filter(p => p.clientId !== previousClientId).length === 0;
  const { state, publicIp } = await getEc2State();
  const isRunning = state === 'running';

  if (!isRunning && wasEmpty) await startTurnServer();  // fire-and-forget

  const turnReady = isRunning && !!publicIp;
  return resp(200, {
    clientId,
    participants,
    turn: credentials,
    turnReady,
    ...(turnReady ? { turnHost: publicIp } : {}),
  });
}

return resp(200, { clientId, participants });
```

### Modified `voiceLeave` (additions only)

```js
// After deleting participant:
const remaining = await getParticipants(roomId);
if (remaining.length === 0) await stopTurnServer().catch(() => {});
return resp(200, {});
```

### New `GET /voice/turn/status`

```js
async function turnStatus() {
  const { state, publicIp } = await getEc2State();
  const ready = state === 'running' && !!publicIp;
  return resp(200, { ready, host: ready ? publicIp : null });
}
```

### Scheduled idle-stop (`turnIdleStop`)

Invoked by EventBridge rule every 5 minutes. Stops EC2 if room is empty.

```js
async function turnIdleStop() {
  const participants = await getParticipants('main');
  if (participants.length > 0) return { stopped: false };
  const { state } = await getEc2State();
  if (state === 'running' || state === 'pending') {
    await stopTurnServer();
    return { stopped: true };
  }
  return { stopped: false };
}
```

---

## Frontend sketch (`src/voice.js` changes)

```js
// Replace the hardcoded STUN const with:
let turnConfig = null;

function buildIceConfig(host, username, credential) {
  return {
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: `turn:${host}:3478`, username, credential },
    ],
  };
}

function stunOnlyConfig() {
  return { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
}

// In joinRoom, after the /voice/join fetch:
const { clientId, participants, turn, turnReady, turnHost } = data;
if (turn) {
  if (turnReady && turnHost) {
    turnConfig = buildIceConfig(turnHost, turn.username, turn.credential);
  } else {
    setStatus('Starting TURN server… (~30s on first join)');
    const host = await waitForTurn();
    turnConfig = buildIceConfig(host, turn.username, turn.credential);
  }
}

// waitForTurn polls /voice/turn/status until ready:
async function waitForTurn() {
  for (let i = 0; i < 30; i++) {
    await new Promise(r => setTimeout(r, 3000));
    const res  = await fetch(`${API_BASE}/voice/turn/status`);
    const data = await res.json();
    if (data.ready && data.host) return data.host;
  }
  throw new Error('TURN server did not start in time');
}

// makePc uses turnConfig (falls back to STUN-only if null):
function makePc(remoteId) {
  const pc = new RTCPeerConnection(turnConfig ?? stunOnlyConfig());
  // ... rest unchanged
}
```

---

## SAM template additions

```yaml
# In ChatFunction > Environment > Variables:
TURN_EC2_INSTANCE_ID: 'i-0REPLACE'   # set to '' to disable
TURN_SECRET: ''                        # set manually after deploy (or use SSM)

# In ChatFunction > Policies (add alongside DynamoDB policies):
- Statement:
    - Effect: Allow
      Action:
        - ec2:StartInstances
        - ec2:StopInstances
        - ec2:DescribeInstances
      Resource: '*'

# New function for scheduled idle-stop:
TurnIdleStopFunction:
  Type: AWS::Serverless::Function
  Properties:
    Handler: handler.turnIdleStopHandler
    CodeUri: .
    Timeout: 15
    MemorySize: 128
    Environment:
      Variables:
        VOICE_TABLE:            !Ref VoiceRoomTable
        TURN_EC2_INSTANCE_ID:   'i-0REPLACE'
        TURN_SECRET:            ''
    Policies:
      - DynamoDBCrudPolicy:
          TableName: !Ref VoiceRoomTable
      - Statement:
          - Effect: Allow
            Action: [ec2:StopInstances, ec2:DescribeInstances]
            Resource: '*'
    Events:
      Schedule:
        Type: Schedule
        Properties:
          Schedule: rate(5 minutes)
```

---

## Security notes

- `TURN_SECRET` must never appear in frontend code or git history
- Set it in Lambda env vars via console or SSM after deploy
- `denied-peer-ip` rules in coturn prevent using the relay to probe AWS internal IPs
  (169.254.x.x metadata, 10.x.x.x VPC, etc.)
- coturn short-term credentials expire after 1 hour — even if stolen they're useless
  past the expiry timestamp embedded in the username
- SSH port 22 should be closed; use SSM Session Manager for maintenance

---

## Verification

CI is the only test runner. After implementing:
1. Push branch → open PR → CI green
2. Merge → deploy
3. Open `voice.html` from a network where direct P2P would fail (or use browser devtools
   to block non-TURN candidates)
4. Confirm TURN credentials appear in the ICE config via browser console
5. Confirm EC2 starts on join, stops on leave (check EC2 console)
6. Confirm audio works end-to-end
